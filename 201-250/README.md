## 总结

1. [201. Bitwise AND of Numbers Range](https://leetcode.com/problems/bitwise-and-of-numbers-range/description/) 是一道位操作的题目，解题方法比较巧妙简约。
2. [202. Happy Number](https://leetcode.com/problems/happy-number/description/)挺有趣，有轻松的一道题目。
3. [203. Remove Linked List Elements](https://leetcode.com/problems/remove-linked-list-elements/description/) 比较简单的链表操作题目
4. [204. Count Primes](https://leetcode.com/problems/count-primes/description/)这是一个定位为easy的问题，但是如果不知道质数筛选法的话，很难写出高性能的算法。
5. [205. Isomorphic Strings](https://leetcode.com/problems/isomorphic-strings/description/) 这道题做着挺舒服的。
6. [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/description/) 旋转链表，对现在的我还是挺简单的。
7. [207. Course Schedule](https://leetcode.com/problems/course-schedule/) 拓扑排序，可以用来熟悉这个函数的写法。
8. [208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/discuss/) trie 树是一个为了特定目的而构建的树，对于统计单词出现的频率和前缀的频率具有比较高的性能。挺有趣的。
9. [209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/description/) 一个测试我自己写流程的题目，难度不大。
10. [210. Course Schedule II](https://leetcode.com/problems/course-schedule-ii/description/) 
11. [211. Add and Search Word - Data structure design](https://leetcode.com/problems/add-and-search-word-data-structure-design/description/) 这个和208这道题是一样的，根据208我们知道trie tree结构对查找单词的性能十分好。所以使用这个算法。
12. [212. Word Search II](https://leetcode.com/problems/word-search-ii/description/) 也是使用trie。现在发现trie真的挺好用的。简单有效
13. [213. House Robber II](https://leetcode.com/problems/house-robber-ii/description/) 在有House Robber的基础上考虑分别不抢前后房子。取最大。
14. [214. Shortest Palindrome](https://leetcode.com/problems/shortest-palindrome/description/) 这道题目很有思考的意义。**要多看**